% 
\documentclass[a4paper,twoside,openany,10pt]{article}
\usepackage[
  a4paper, mag=1000, includefoot,
  left=2cm, right=2cm, top=2cm, bottom=2cm, headsep=1cm, footskip=1cm
]{geometry}
\usepackage[OT1]{fontenc}
\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage[english]{babel}
\ifpdf\usepackage{epstopdf}\fi
%\usepackage[pdftex]{graphicx} 
%\usepackage{graphicx, subfigure}
%\usepackage[]{subfig}
%\usepackage[colorlinks,urlcolor=blue]{hyperref} 
\usepackage{float}
\usepackage{alltt}

\usepackage{color}
\definecolor{lightgray}{gray}{0.95}

\usepackage{listings}
\lstset{
language=R,                			% choose the language of the code
basicstyle=\verbatim@font,      % the size of the fonts that are used for the code
%breaklines=true,                % sets automatic line breaking
%breakatwhitespace=true,					%force breaks at white space
showspaces=false,								%don't display funky characters where there are spaces
showstringspaces=false,					%show spaces within strings
columns=fullflexible,						%makes character spacing nice
,captionpos=t,tabsize=3,frame=tb,
%   keywordstyle=\color{blue},
%   commentstyle=\color{gray},stringstyle=\color{red},
   numbers=right,
   numberstyle=\small,
   numbersep=5pt,breaklines=true,showstringspaces=false,
   basicstyle=\footnotesize,emph={label},breakatwhitespace=false,escapeinside={`}{`}
}
\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Listing}


%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{MplusAutomation Examples}

\begin{document}
<<setup, include = FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=70)
library(xtable)
@

\setlength{\parindent}{0cm}
\setlength{\parskip}{0.3cm}
\title{RKappa ABC complex Examples}
\author{Anatoly Sorokin}
\date{Package version 1.0.140923}
\maketitle
\tableofcontents
\bigskip
\section{Overview}

Dynamic modelling of biological processes is now established as a powerful tool for revealing the systems-level behaviour emerging from the interaction of molecular components. Modelling techniques based on a range mathematical grounds have been introduced over the past century, including kinetic modelling, deterministic and stochastic Petri nets, logical Boolean modelling, etc. The choice of the modelling approach generally depends upon system size, complexity, level of kinetic detail available and expected outcome. However, for a given model building task, there is no guarantee that a sufficient number of parameters are known well enough to approach biological plausibility or to ensure that the resulting simulation will be computationally tractable.

A relatively new modelling approach – rule-based modelling – is one of several developed to deal with combinatorial complexity emerging in multicomponent multistate systems [1]. These have been implemented using several different semantics (Kappa, BioNetGen, StochSim, etc.) and successfully applied to a number of well-described signalling pathways [2-4]. Rule-based modelling enables representation, simulation and analysis of the behaviour of large-scale systems where knowledge of exact mechanisms and parameters is limited. These features make it very appealing to a wide variety of biological modelling problems [5].

The process of building and analysing a dynamic model generally consists of the following essential steps: model assembling, model simulation, analysis of the results and model revision. As a rule, the whole process is highly iterative, therefore, an general–purpose infrastructure that supports all the steps described above would be desirable. 

Indeed, for other widely used modeling techniques, such as ODE solving, a number of effective infrastructures (toolboxes) have been developed and subsequently proven their value such as COPASI, SBTOOLBOX2, SBML-SAT, SBML-PET, PottersWheel, etc [8-12]. As an example, SBTOOLBOX2 is based around the SUNDIALS simulating engine and includes a library of Matlab scripts that support model development, model simulation, fitting of models to experimental results, parameter estimation and analysis of results, including the important options for sensitivity and identifiability analysis [10]. The SBML-SAT toolbox provides the Matlab platform for local and global sensitivity analysis [11].

For the relatively new rule-based techniques, such infrastructure is sparse in its coverage. For example, a Matlab-based library is available for BioNetGen, enabling parameter scanning, visualization and analysis of simulation results [13]. 

What is clearly needed is a method that facilitates the development and analysis of rule-based models within a mature statistically empowered framework. Here we present the R-Kappa package that embodies this need in the widely available statistical package R and demonstrate its effectiveness through its application to Global Sensitivity Analysis (GSA).

In addition to traditional GSA that we call here “parallel” for simplicity, we have introduced a computational experimental setup based upon the distinctive compositionality feature of rule-based models, which was named “concurrent” sensitivity. 

\section{Illustration model description}
Here we illustrate the concept with small toy model of interaction of three agents A, B and C.  The kappa model is in Listing~\ref{code:cABC} and the graphical representation of interactions between agents are shown on the Fig.~\ref{fig:contact.map}. According them B can bind either A or C, but not both (lines~\ref{lst:a.not.c},~\ref{lst:c.not.a} on the Listing~\ref{code:cABC}). We going to calculate sensitivity of AB fraction of B agent.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.7]{./figures/abcContacts.jpg}
\caption{Contact map for the model from Listing~\ref{code:cABC}}
\label{fig:contact.map}
\end{center}
\end{figure}


\begin{program}[htbp]
%  \begin{verbatim}
\begin{lstlisting}

#Agent definition
%agent: A(s)
%agent: B(s,t)
%agent: C(s)

# Reaction kinetic parameters
`\label{lst:vol.def}`%var: 'vol' 0.1
`\label{lst:bind.def}`%var: 'BDB' 0.0005
%var: 'BRK' 0.1

# Variables definition
%var: 'nA'  1000 * 'vol'
%var: 'nB'  1000 * 'vol'
%var: 'nC'  1000 * 'vol'
%var: 'BND' 'BDB' / 'vol' # Bimolecular reaction rate depends upon volume

# Reaction rules
`\label{lst:a.not.c}`'assocAB'  A(s), B(s,t) -> A(s!0), B(s!0,t) @ 'BND'
'dissocAB' A(s!0), B(s!0) -> A(s), B(s) @ 'BRK'
`\label{lst:c.not.a}`'assocBC'  B(t,s), C(s) -> B(t!0,s), C(s!0) @ 'BND'
'dissocBC' B(t!0), C(s!0) -> B(t), C(s) @ 'BRK'

# Initial conditions definition
%init: 'nA' A(s)
%init: 'nB' B(s,t)
%init: 'nC' C(s)

# Observables 
%obs: 'AB' B(s!_)
%obs: 'BC' B(t!_)
%obs: 'B' B(s,t)
%obs: 'AB fraction' 'AB' / 'B'

# Snapshot definition
%mod: repeat ([E+] [mod] 1000)=0 do $SNAPSHOT "cABC" until [false]
\end{lstlisting}
%\end{verbatim}
  \caption{The toy kappa model of B interacting with A and C.}
  \label{code:cABC}

\end{program}

\section{Project definition}

We will start working with library rkappa by loading it:
<<load-library, include = TRUE, cache=FALSE, results='hide'>>=
library(rkappa)
@

The model depends upon three parameters: system volume $vol$ (line~\ref{lst:vol.def}); binding rate constant $BDB$ (line~\ref{lst:bdb.def}); and dissociation rate constant $BRK$ (line~\ref{lst:brk.def}). For analysis we have to provide boundaries for those parameters. In our case we set boundaries for all parameters so that their value will be always between $10^{-9}$ and $1$:

<<prepare-parTab,  cache=FALSE>>=
parTable<-data.frame(param=c('vol','BDB','BRK'),Min=1e-9,Max=1.0,stringsAsFactors=FALSE)
@
result is shown below:
<<print-parTab,  echo = FALSE, results = 'asis'>>=
xtable(parTable)
@

The key element of the RKappa library is the kproject class. Objects of that class stores all information required for generation of 

<<make-project, cache=TRUE,warning=FALSE>>=
abcProj<-prepareProject(project='abc',
     numSets=50,
     exec.path="~/kasim3/KaSim",
     constantfiles=c(),
     templatefiles=c("cABC_templ.ka"),
     paramfile=c("cABC_param.ka"),
     type='parallel')
@

<<list-shells, cache=FALSE>>=
print(abcProj$shLines)
@

<<update-run.sh, cache=FALSE,tidy_source=TRUE>>=
abcProj$shLines[["run.sh.templ"]][2]<-"numEv=2"
abcProj$shLines[["run.sh.templ"]][16]<-
"$KASIM_EXE _- -e $time -p 100 -d \"./pset***/try$i\" -make-sim prom.kasim"
abcProj$shLines[["run.sh.templ"]][21]<-
"$KASIM_EXE -e $time -p 100 -d \"./pset***/try$i\" -load-sim  ./pset***/try1/prom.kasim"

 abcProj$shLines[["run.sh.templ"]]
@

<<update-job.sh, cache=FALSE,tidy_source=TRUE>>=
 abcProj$shLines[["job.sh.templ"]][20]<-"#N=$SGE_TASK_ID"
 abcProj$shLines[["job.sh.templ"]][21]<-"for runN in $(ls run*.sh)"
 abcProj$shLines[["job.sh.templ"]][22]<-"do"
 abcProj$shLines[["job.sh.templ"]][23]<-"echo $runN"
 abcProj$shLines[["job.sh.templ"]][24]<-"./$runN"
 abcProj$shLines[["job.sh.templ"]][25]<-"done"

 abcProj$shLines[["job.sh.templ"]]
@
\end{document}
